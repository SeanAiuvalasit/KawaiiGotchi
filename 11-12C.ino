#include <Arduino.h>
#include "HX711.h"
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>


// --------- Pins ----------
#define DOUT_PIN    33
#define SCK_PIN     14
#define BUZZER_PIN  27
#define SDA_PIN     22
#define SCL_PIN     21


// --------- Display ----------
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);


// --------- Scale ----------
HX711 scale;
float CAL_FACTOR = 2280.0f;     // adjust after calibration


// --------- Thresholds (grams/mL) ----------
const float THRESHOLD_ON   = 15.0f;     // enter "present" when >= this
const float THRESHOLD_OFF  = 8.0f;      // leave "present" when <= this
const float MIN_SIP        = 5.0f;      // minimum delta to count as a sip
const float STABLE_EPS     = 2.0f;      // small deadband for “stable”
const unsigned long DROP_DEBOUNCE_MS = 1500; // drop must persist this long


// --------- “Enough?” per-sip rule ----------
const float ENOUGH_PER_SIP_ML = 100.0f; // adjust your per-sip target


// --------- State Machine ----------
enum State { NO_BOTTLE, BOTTLE_PRESENT };
State state = NO_BOTTLE;


// --------- Baselines / detection helpers ----------
float presentMaxBaseline = 0.0f;  // max stable level while present
float lastStableLevel    = 0.0f;  // last accepted plateau


bool  dropArmed           = false;  // tracking a candidate drop
float dropStartLevel      = 0.0f;
unsigned long dropStartMs = 0;


// remove/return decision uses this
float pendingBeforeRemoval = 0.0f;


// timing for “waiting for sips…” hint
unsigned long presentSinceMs = 0;  // set when bottle becomes present


// --------- Bitmaps (converted from your files, 64x64, 1-bit) ----------
#define KAWAII_W 64
#define KAWAII_H 64


// Happy cat 64x64 (from: epd_bitmap_ (1).bin), 1-bit, row-packed (LSB first)
const unsigned char PROGMEM kawaii_happy[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
  0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF,
  0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF,
  0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xDF, 0xFB, 0xFF, 0xFF,
  0xFF, 0xDF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0x6F, 0xB6, 0xDB, 0xFF, 0xFF,
  0xFF, 0xAD, 0xFD, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0x7F, 0xB3, 0x6D, 0xB7, 0xDB, 0xFF,
  0x6D, 0xDB, 0xEC, 0xFF, 0x01, 0x00, 0x00, 0x80, 0xFF, 0xBF, 0x59, 0x6F, 0xB6, 0xDB, 0x6E, 0xDB,
  0xB6, 0xB5, 0xF6, 0xFF, 0x01, 0x00, 0x80, 0xFF, 0xDF, 0xCD, 0xDA, 0xB6, 0x6D, 0xDB, 0xB6, 0xB5,
  0x6D, 0xBB, 0xFD, 0x7F, 0x00, 0x80, 0xFF, 0xDF, 0xCC, 0xB6, 0x6D, 0xDB, 0xB6, 0x6D, 0x6B, 0xDB,
  0xB6, 0x6D, 0xFB, 0x7F, 0x80, 0xFF, 0xDF, 0xCC, 0xB6, 0x6D, 0xDB, 0xB6, 0x6D, 0x6B, 0xDB, 0xB6,
  0x6D, 0xBB, 0xFD, 0x7F, 0x80, 0xFF, 0xDF, 0xCD, 0xDA, 0xB6, 0x6D, 0xDB, 0xB6, 0xB5, 0x6D, 0xBB,
  0xF6, 0xFE, 0x7F, 0x80, 0xFF, 0x7F, 0xB3, 0x6D, 0xB7, 0xDB, 0xFF, 0x6D, 0xDB, 0xEC, 0xFF, 0x7F,
  0x80, 0xFF, 0x6F, 0xB6, 0xDB, 0xFF, 0xFF, 0xFF, 0xAD, 0xFD, 0xFF, 0x7F, 0x80, 0xFF, 0xDF, 0xFB,
  0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0x7D, 0x7F, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00,
  0x80, 0xFF, 0x1F, 0x7F, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x80, 0x7F, 0x00, 0x7E,
  0x80, 0x3F, 0xFC, 0xFF, 0xE1, 0x03, 0x18, 0x00, 0x78, 0x00, 0x3E, 0x80, 0x0F, 0xF0, 0x7F, 0x80,
  0x03, 0x18, 0x00, 0x60, 0x00, 0x18, 0x80, 0x07, 0x80, 0x1F, 0x00, 0x00, 0x03, 0x18, 0x00, 0x60,
  0x00, 0x18, 0x80, 0x07, 0x80, 0x1F, 0x00, 0x00, 0x03, 0x18, 0x00, 0x60, 0x00, 0x18, 0x80, 0x07,
  0x80, 0x1F, 0x00, 0x00, 0x03, 0x18, 0x00, 0x60, 0x00, 0x18, 0x80, 0x0F, 0xF0, 0x7F, 0x80, 0x03,
  0x18, 0x00, 0x60, 0x00, 0x18, 0x80, 0x3F, 0xFC, 0xFF, 0xE1, 0x03, 0x18, 0x00, 0x78, 0x00, 0x3E,
  0x80, 0x7F, 0x00, 0x7E, 0x80, 0xFF, 0x1F, 0x7F, 0x80, 0xFF, 0x03, 0x00, 0x80, 0xFF, 0xFF, 0xFF,
  0xFF, 0x7F, 0x80, 0xFF, 0x7D, 0x7F, 0x80, 0xFF, 0x6F, 0xB6, 0xDB, 0xFF, 0xFF, 0xFF, 0xAD, 0xFD,
  0xFF, 0x7F, 0x80, 0xFF, 0x7F, 0xB3, 0x6D, 0xB7, 0xDB, 0xFF, 0x6D, 0xDB, 0xEC, 0xFF, 0x7F, 0x80,
  0xFF, 0xDF, 0xCD, 0xDA, 0xB6, 0x6D, 0xDB, 0xB6, 0xB5, 0x6D, 0xBB, 0xF6, 0xFE, 0x7F, 0x80, 0xFF,
  0xDF, 0xCC, 0xB6, 0x6D, 0xDB, 0xB6, 0x6D, 0x6B, 0xDB, 0xB6, 0x6D, 0xBB, 0xFD, 0x7F, 0x80, 0xFF,
  0xDF, 0xCC, 0xB6, 0x6D, 0xDB, 0xB6, 0x6D, 0x6B, 0xDB, 0xB6, 0x6D, 0xBB, 0xFD, 0x7F, 0x00, 0x80,
  0xFF, 0xDF, 0xCD, 0xDA, 0xB6, 0x6D, 0xDB, 0xB6, 0xB5, 0x6D, 0xBB, 0xFD, 0x7F, 0x00, 0x80, 0xFF,
  0x7F, 0xB3, 0x6D, 0xB7, 0xDB, 0xFF, 0x6D, 0xDB, 0xEC, 0xFF, 0x7F, 0x00, 0x80, 0xFF, 0x6F, 0xB6,
  0xDB, 0xFF, 0xFF, 0xFF, 0xAD, 0xFD, 0xFF, 0x7F, 0x00, 0x80, 0xFF, 0xDF, 0xFB, 0xFF, 0xFF, 0xFF,
  0xDF, 0xFF, 0x7D, 0x7F, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x80, 0xFF,
  0x1F, 0x7F, 0x00, 0xF0, 0xFF, 0xFF, 0x0F, 0x00, 0x80, 0x3F, 0xFE, 0x3F, 0x00, 0xC0, 0xFF, 0xFF,
  0x03, 0x00, 0x80, 0x07, 0xF0, 0x07, 0x00, 0x00, 0xFE, 0x7F, 0x00, 0x00, 0x80, 0x07, 0xF0, 0x07,
  0x00, 0x00, 0xFE, 0x7F, 0x00, 0x00, 0x80, 0x07, 0xF0, 0x07, 0x00, 0xC0, 0xFF, 0xFF, 0x03, 0x00,
  0x80, 0x3F, 0xFE, 0x3F, 0x00, 0xF0, 0xFF, 0xFF, 0x0F, 0x00, 0x80, 0xFF, 0x1F, 0x7F, 0x00, 0xFC,
  0xFF, 0xFF, 0x3F, 0x00
};


// Disappointed face 64x64 (from: epd_bitmap_ (2).bin), 1-bit, row-packed (LSB first)
const unsigned char PROGMEM kawaii_disappointed[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xF7,
  0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x3F, 0xFF,
  0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xBF, 0xC9, 0xBE, 0xFF, 0xFE,
  0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7F, 0x93, 0x24, 0x69, 0xDE, 0xF7, 0xFD, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x80, 0x7F, 0x93, 0x24, 0x49, 0x92, 0xB4, 0xDE, 0xFB, 0x03, 0x00, 0x00,
  0x00, 0x80, 0x3F, 0x49, 0x92, 0x24, 0x49, 0x92, 0xA4, 0xF5, 0xFE, 0x07, 0x00, 0x00, 0x80, 0x3F,
  0x49, 0x92, 0x24, 0x49, 0x92, 0x24, 0x49, 0xEA, 0xFD, 0x0F, 0x00, 0x00, 0x80, 0x1F, 0x49, 0x92,
  0x24, 0x49, 0x92, 0x24, 0x49, 0x92, 0xF4, 0xFF, 0x1F, 0x00, 0x00, 0xC0, 0x8F, 0x24, 0x49, 0x92,
  0x24, 0x49, 0x92, 0x24, 0x49, 0xEA, 0xFF, 0x3F, 0x00, 0x00, 0xE0, 0x47, 0x92, 0x24, 0x49, 0x92,
  0x24, 0x49, 0x92, 0x24, 0x49, 0xFA, 0xFF, 0x7F, 0x00, 0x00, 0xF0, 0x23, 0x49, 0x92, 0x24, 0x49,
  0x92, 0x24, 0x49, 0x92, 0xA4, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0xF8, 0x91, 0x24, 0x49, 0x92, 0x24,
  0x49, 0x92, 0x24, 0x49, 0xDA, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xFC, 0x48, 0x92, 0x24, 0x49, 0x92,
  0x24, 0x49, 0x92, 0xA4, 0xED, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x3E, 0x24, 0x49, 0x92, 0x24, 0x49,
  0x92, 0x24, 0x49, 0xD2, 0xFE, 0xFF, 0x7F, 0x7F, 0x07, 0x00, 0x1F, 0x12, 0x49, 0x92, 0x24, 0x49,
  0x92, 0x24, 0x49, 0xFA, 0xF7, 0xFF, 0x6F, 0x2F, 0x0E, 0x80, 0x0F, 0x89, 0x24, 0x49, 0x92, 0x24,
  0x49, 0x92, 0x24, 0x7D, 0xE3, 0xFF, 0xE7, 0xC7, 0x1C, 0xC0, 0x87, 0x44, 0x92, 0x24, 0x49, 0x92,
  0x24, 0x49, 0xD2, 0xBF, 0xC1, 0xFF, 0xF3, 0xC3, 0x39, 0xE0, 0x43, 0x22, 0x49, 0x92, 0x24, 0x49,
  0x92, 0xA4, 0xB4, 0xDF, 0xE0, 0xFF, 0xF9, 0xF1, 0x73, 0xF0, 0x21, 0x11, 0x49, 0x92, 0x24, 0x49,
  0xD2, 0x5E, 0xDA, 0x6F, 0xF0, 0xFF, 0xFC, 0xF8, 0x39, 0xF8, 0x90, 0x88, 0x24, 0x49, 0x92, 0xA4,
  0xB4, 0xD7, 0xF6, 0x37, 0xF8, 0x7F, 0x7E, 0x7C, 0x1E, 0x7C, 0x48, 0x44, 0x92, 0x24, 0x49, 0xDA,
  0x6D, 0x7B, 0x1B, 0x7C, 0x3F, 0x3F, 0x3E, 0x0F, 0x3E, 0x24, 0x22, 0x49, 0x92, 0xB4, 0xD7, 0xF6,
  0x37, 0x7E, 0x9E, 0x9F, 0x9F, 0x07, 0x1F, 0x12, 0x11, 0x49, 0xDA, 0x6D, 0x7B, 0x1B, 0x3F, 0xCF,
  0xCF, 0xCF, 0x03, 0x0F, 0x89, 0x88, 0xA4, 0xBD, 0xB6, 0xBF, 0xF1, 0xF3, 0xFC, 0xFC, 0x3C, 0xF0,
  0x43, 0x44, 0x24, 0xED, 0xB5, 0xFD, 0xCD, 0x9F, 0xE7, 0xE7, 0xE7, 0x81, 0x07, 0x22, 0x22, 0xE9,
  0xB6, 0xBD, 0x8D, 0x9F, 0xE7, 0xE7, 0xE7, 0x81, 0x07, 0x22, 0x22, 0xA9, 0xB7, 0xBD, 0x8D, 0x9F,
  0xE7, 0xE7, 0xE7, 0x81, 0x07, 0x22, 0x22, 0xA9, 0xB7, 0xBD, 0x8D, 0x9F, 0xE7, 0xE7, 0xE7, 0x81,
  0x07, 0x22, 0x22, 0xA9, 0xB7, 0xBD, 0x8D, 0x9F, 0xE7, 0xE7, 0xE7, 0x81, 0x07, 0x22, 0x22, 0xA9,
  0xB7, 0xBD, 0x8D, 0x9F, 0xE7, 0xE7, 0xE7, 0x81, 0x07, 0x22, 0x22, 0xA9, 0xB7, 0xBD, 0x8D, 0x9F,
  0xE7, 0xE7, 0xE7, 0x81, 0x07, 0x22, 0x22, 0xA9, 0xB7, 0xBD, 0x8D, 0x9F, 0xE7, 0xE7, 0xE7, 0x81,
  0x07, 0x22, 0x22, 0xA9, 0xB7, 0xBD, 0x8D, 0x9F, 0xE7, 0xE7, 0xE7, 0x81, 0x0F, 0x11, 0x11, 0x49,
  0xDB, 0x6D, 0x7B, 0x1B, 0x3F, 0xCF, 0xCF, 0xCF, 0x03, 0x1F, 0x12, 0x11, 0x49, 0xB5, 0xD7, 0xF6,
  0x37, 0x7E, 0x9E, 0x9F, 0x9F, 0x07, 0x3E, 0x24, 0x22, 0x49, 0xDA, 0x6D, 0x7B, 0x1B, 0x7C, 0x3F,
  0x3F, 0x3E, 0x0F, 0x7C, 0x48, 0x44, 0x92, 0xB4, 0xD7, 0xF6, 0x37, 0xF8, 0x7F, 0x7E, 0x7C, 0x1E,
  0xF8, 0x90, 0x88, 0x24, 0x69, 0xDA, 0x6F, 0xF0, 0xFF, 0xFC, 0xF8, 0x39, 0xF0, 0x21, 0x11, 0x49,
  0x92, 0xB4, 0xDF, 0xE0, 0xFF, 0xF9, 0xF1, 0x73, 0xE0, 0x43, 0x22, 0x49, 0x92, 0xA4, 0xB4, 0xDF,
  0xC1, 0xFF, 0xF3, 0xC3, 0x39, 0xC0, 0x87, 0x44, 0x92, 0x24, 0x49, 0xDA, 0x6F, 0x83, 0xFF, 0xE7,
  0xC7, 0x1C, 0x80, 0x0F, 0x89, 0x24, 0x49, 0xB2, 0xDF, 0x06, 0xFF, 0xCF, 0x8F, 0x9B, 0x00, 0x1F,
  0x12, 0x49, 0x92, 0x7C, 0xBF, 0x0D, 0xFE, 0x9F, 0x1F, 0x37, 0x01, 0x3E, 0x24, 0x92, 0x24, 0xF9,
  0x7E, 0x1B, 0xFC, 0x3F, 0x3F, 0x6E, 0x02, 0x7C, 0x48, 0x24, 0x49, 0xF2, 0xFD, 0x36, 0xF8, 0x7F,
  0x7E, 0xDC, 0x04, 0xF8, 0x90, 0x48, 0x92, 0xE4, 0xFB, 0x6D, 0xF0, 0xFF, 0xFC, 0xB8, 0x09, 0xF0,
  0x21, 0x91, 0x24, 0xC9, 0xF7, 0xDB, 0xE0, 0xFF, 0xF9, 0x71, 0x13, 0xE0, 0x43, 0x22, 0x49, 0x92,
  0xEF, 0xB7, 0xC1, 0xFF, 0xF3, 0xB3, 0x26, 0xC0, 0x87, 0x44, 0x92, 0x24, 0xDF, 0x6F, 0x83, 0xFF,
  0xE7, 0x67, 0x4D, 0x80, 0x0F, 0x89, 0x24, 0x49, 0xBE, 0xDF, 0x06, 0xFF, 0xCF, 0xCF, 0x9A, 0x00,
  0x1F, 0x12, 0x49, 0x92, 0x7C, 0xBF, 0x0D, 0xFE, 0x9F, 0x9F, 0x35, 0x01, 0x3E, 0x24, 0x92, 0x24,
  0xF9, 0x7E, 0x1B, 0xFC, 0x3F, 0x3F, 0x6B, 0x02, 0x7C, 0x48, 0x24, 0x49, 0xF2, 0xFD, 0x36, 0xF8,
  0x7F, 0x7E, 0xD6, 0x04, 0xF8, 0x90, 0x48, 0x92, 0xE4, 0xFB, 0x6D, 0xF0, 0xFF, 0xFC, 0xAC, 0x09,
  0xF0, 0x21, 0x91, 0x24, 0xC9, 0xF7, 0xDB, 0xE0, 0xFF, 0xF9, 0x59, 0x13, 0xE0, 0x43, 0x22, 0x49,
  0x92, 0xEF, 0xB7, 0xC1, 0xFF, 0xF3, 0xB3, 0x26, 0xC0, 0x87, 0x44, 0x92, 0x24, 0xDF, 0x6F, 0x83,
  0xFF, 0xE7, 0x67, 0x4D, 0x80, 0x0F, 0x89, 0x24, 0x49, 0xBE, 0xDF, 0x06, 0xFF, 0xCF, 0xCF, 0x9A,
  0x00, 0x1F, 0x12, 0x49, 0x92, 0x7C, 0xBF, 0x0D, 0xFE, 0x9F, 0x9F, 0x35, 0x01, 0x3E, 0x24, 0x92,
  0x24, 0xF9, 0x7E, 0x1B, 0xFC, 0x3F, 0x3F, 0x6B, 0x02, 0x7C, 0x48, 0x24, 0x49, 0xF2, 0xFD, 0x36,
  0xF8, 0x7F, 0x7E, 0xD6, 0x04, 0xF8, 0x90, 0x48, 0x92, 0xE4, 0xFB, 0x6D, 0xF0, 0xFF, 0xFC, 0xAC,
  0x09, 0xF0, 0x21, 0x91, 0x24, 0xC9, 0xF7, 0xDB, 0xE0, 0xFF, 0xF9, 0x59, 0x13, 0xE0, 0x43, 0x22,
  0x49, 0x92, 0xEF, 0xB7, 0xC1, 0xFF, 0xF3, 0xB3, 0x26, 0x00
};


// --------- Helpers ----------
void buzz(uint16_t freq, uint16_t durMs) { tone(BUZZER_PIN, freq, durMs); }


void displayLines(const String &l1, const String &l2 = "", const String &l3 = "") {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);


  display.setCursor(0, 0);
  display.println("Kawaiigochi");
  display.drawLine(0, 10, 127, 10, SSD1306_WHITE);


  if (l1.length()) { display.setCursor(0, 18); display.println(l1); }
  if (l2.length()) { display.setCursor(0, 30); display.println(l2); }
  if (l3.length()) { display.setCursor(0, 42); display.println(l3); }


  display.display();
}


// Show weight; optionally include the “Waiting for sips...” hint
void showWeight(float w, bool showWaitingHint) {
  if (showWaitingHint) {
    displayLines(String("Weight: ") + String(w, 1) + " g", "Waiting for sips...");
  } else {
    displayLines(String("Weight: ") + String(w, 1) + " g");
  }
}


// Smoothed reading (grams ≈ mL)
float readWeight() { return scale.get_units(10); }


// When a drink is detected
void onDrink(float amount) {
  bool enough = (amount >= ENOUGH_PER_SIP_ML);


  display.clearDisplay();
  // Center a 64x64 image on a 128x64 screen -> x = 32, y = 0
  if (enough) {
    display.drawBitmap(32, 0, kawaii_happy, KAWAII_W, KAWAII_H, SSD1306_WHITE);
  } else {
    display.drawBitmap(32, 0, kawaii_disappointed, KAWAII_W, KAWAII_H, SSD1306_WHITE);
  }


  // Text near bottom
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 52);
  display.print("Drank: ");
  display.print(amount, 0);
  display.print(" mL  ");
  display.print("Enough: ");
  display.print(enough ? "Yes" : "No");
  display.display();


  buzz(enough ? 1200 : 800, enough ? 150 : 250);
  delay(10000); // keep result for 10 seconds
}


void setup() {
  Serial.begin(115200);
  pinMode(BUZZER_PIN, OUTPUT);


  Wire.begin(SDA_PIN, SCL_PIN);
  Wire.setClock(100000);


  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    // continue even if display not found
  }
  display.clearDisplay();
  display.display();


  scale.begin(DOUT_PIN, SCK_PIN);
  scale.set_scale(CAL_FACTOR);
  scale.tare();


  displayLines("Hi! I'm Kawaiigochi", "Let's stay hydrated!");
  delay(1200);
}


void loop() {
  float w = readWeight(); // negative is fine


  switch (state) {
    case NO_BOTTLE: {
      // If returning after removal, decide immediately when it reappears
      if (pendingBeforeRemoval > 0.0f && w >= THRESHOLD_ON) {
        float delta = pendingBeforeRemoval - w; // positive = drank while away
        if (delta >= MIN_SIP) onDrink(delta);


        // initialize baselines
        presentMaxBaseline   = w;
        lastStableLevel      = w;
        dropArmed            = false;
        pendingBeforeRemoval = 0.0f;


        // start the 20s window before showing the waiting hint
        presentSinceMs = millis();


        state = BOTTLE_PRESENT;
        showWeight(w, false); // no "Waiting..." yet
        delay(120);
        return;
      }


      // Fresh appearance with no pending decision
      if (w >= THRESHOLD_ON) {
        presentMaxBaseline = w;
        lastStableLevel    = w;
        dropArmed          = false;


        // start the 20s window before showing the waiting hint
        presentSinceMs = millis();


        state = BOTTLE_PRESENT;
        displayLines("Bottle detected!", "Hello!");
        delay(300);
      } else {
        // No bottle present; just show the weight line (no waiting hint)
        showWeight(w, false);
      }
    } break;


    case BOTTLE_PRESENT: {
      // Track the highest stable level while present
      if (w > presentMaxBaseline) presentMaxBaseline = w;


      // Case A: sip without removal (sustained drop)
      float deltaFromStable = lastStableLevel - w;


      if (!dropArmed) {
        if (deltaFromStable >= MIN_SIP) {
          dropArmed      = true;
          dropStartLevel = lastStableLevel;
          dropStartMs    = millis();
        }
      } else {
        if (millis() - dropStartMs >= DROP_DEBOUNCE_MS) {
          float consumed = dropStartLevel - w;
          if (consumed >= MIN_SIP) {
            onDrink(consumed);
            lastStableLevel = w; // new plateau after sip
            // After onDrink, continue normal display rules
          }
          dropArmed = false;
        } else {
          // Cancel if it bounced back
          if (w >= dropStartLevel - STABLE_EPS) dropArmed = false;
        }
      }


      // Allow stable level to creep up between sips
      if (fabs(w - lastStableLevel) > STABLE_EPS && w > lastStableLevel)
        lastStableLevel = w;


      // Case B: bottle removed
      if (w <= THRESHOLD_OFF) {
        pendingBeforeRemoval = presentMaxBaseline; // remember pre-removal level
        state = NO_BOTTLE;
        displayLines("Bottle removed", "See you soon!");
        delay(250);
      } else {
        // Show "Waiting for sips..." only after 20s from placement
        bool showHint = (millis() - presentSinceMs >= 20000UL);
        showWeight(w, showHint);
      }
    } break;
  }


  delay(120);
}
